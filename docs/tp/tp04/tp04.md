# TP 04 : Introduction aux *Design Patterns*

[â¬‡ï¸ TÃ©lÃ©charger le TP (tp04.zip)](tp04.zip)

!!! note "Objectif du TP"

    Lâ€™objectif de ce TP est de dÃ©couvrir et de pratiquer les **design patterns structurels** Ã  travers des exemples simples et concrets.  
    Vous allez ici manipuler deux patterns :
    
    - les **dÃ©corateur** 
    - les **composites** 

    ğŸ’¡ Ce TP met lâ€™accent sur la **rÃ©utilisabilitÃ©**, la **composition dâ€™objets** et la **sÃ©paration des responsabilitÃ©s**.

---

!!! note "Instructions prÃ©liminaires"

    Avant de commencer ce TP, vous devez :

    1. CrÃ©er un **nouveau dÃ©pÃ´t GitHub** nommÃ© `tp04-patterns`.  
    2. Ajouter le compte **[@rezakaziz](https://github.com/rezakaziz)** comme **collaborateur** du projet.  
    3. Clonez votre dÃ©pÃ´t en local et travaillez dessus pour les exercices suivants.  
    4. Commitez et poussez rÃ©guliÃ¨rement vos modifications :
       ```bash
       git add .
       git commit -m "progression"
       git push
       ```

---

!!! info "Note"
    Les tests unitaires sont Ã  Ã©crire par l'Ã©tudiant.

## Exercice 1 : Le pattern *DÃ©corateur*

!!! note "Contexte"

    Ce premier exercice sâ€™inspire de la bibliothÃ¨que `itertools` de Python.  
    Lâ€™objectif est de travailler sur des **sÃ©quences de chaÃ®nes de caractÃ¨res**, en construisant progressivement une hiÃ©rarchie dâ€™objets qui permettent de *dÃ©corer* une sÃ©quence existante avec des comportements supplÃ©mentaires.  

    On suppose quâ€™on dispose dâ€™une **interface** `Sequence` dÃ©finissant une mÃ©thode :
    ```java
    String ligneSuivante();
    ```
    ainsi quâ€™une implÃ©mentation de base, `ArraySequence`, qui sâ€™appuie sur un tableau de `String`.

---

!!! Question "Question 1 â€” DÃ©corateur UpperCase"

    Ã‰crivez et testez une classe `UpperCaseDecoratorSequence`, qui sera un **dÃ©corateur** de `Sequence`.  
    Elle renverra les chaÃ®nes de caractÃ¨res en **majuscules**.

    ğŸ’¡ *Rappel :* un dÃ©corateur doit **implÃ©menter la mÃªme interface** que lâ€™objet quâ€™il dÃ©core, et **dÃ©lÃ©guer** une partie du comportement Ã  lâ€™objet dÃ©corÃ©.

    âœ… Exemple :
    ```java
    Sequence s = new UpperCaseDecoratorSequence(new ArraySequence(lignes));
    System.out.println(s.ligneSuivante());
    ```

---

!!! Question "Question 2 â€” DÃ©corateur Grep"

    Ã‰crivez et testez une classe `GrepSequence`, qui sera un dÃ©corateur filtrant les lignes dâ€™une autre sÃ©quence selon un texte donnÃ©.  

    Exemple dâ€™utilisation :
    ```java
    GrepSequence s = new GrepSequence(autreSequence, "chemin");
    String l;
    while ((l = s.ligneSuivante()) != null) {
        System.out.println(l);
    }
    ```

    affiche uniquement les lignes de `autreSequence` contenant le mot `"chemin"`.

    ğŸ’­ **Pistes de rÃ©flexion**
    - Pourquoi un dÃ©corateur est-il plus flexible quâ€™un hÃ©ritage direct ?
    - Que se passerait-il si on voulait combiner `UpperCaseDecoratorSequence` et `GrepSequence` ?

---

!!! Question "Question 3 â€” DÃ©corateur LineNumber"

    Ã‰crivez et testez une classe `LineNumberSequence`, qui sera un dÃ©corateur de `Sequence` maintenant en mÃ©moire le **numÃ©ro de la derniÃ¨re ligne lue**.  

    Exemple :
    ```java
    LineNumberSequence s = new LineNumberSequence(autreSequence);
    String l;
    while ((l = s.ligneSuivante()) != null) {
        System.out.println(s.getLineNumber() + ": " + l);
    }
    ```

    ğŸ’¡ **IdÃ©e clÃ© :**
    - Vous pouvez stocker le compteur de lignes dans une variable dâ€™instance incrÃ©mentÃ©e Ã  chaque lecture.

---

!!! Question "Question 4 â€” DÃ©corateur Slice"

    CrÃ©ez une classe `SliceSequence`, qui sera un dÃ©corateur renvoyant **seulement une partie** des lignes de la sÃ©quence dâ€™origine.  
    Le constructeur prendra deux entiers :
    - `start` : indice de la premiÃ¨re ligne incluse
    - `end` : indice de la premiÃ¨re ligne Ã  ignorer.

    Exemple :
    ```java
    SliceSequence s = new SliceSequence(autreSequence, 10, 20);
    String l;
    while ((l = s.ligneSuivante()) != null) {
        System.out.println(l);
    }
    ```
    Cet exemple affiche les lignes de 10 (incluse) Ã  20 (exclue).

    ğŸ’¡ **Astuce :**
    RÃ©utilisez votre implÃ©mentation de la `LineNumberSequence` pour simplifier la gestion des indices !

---

!!! info "Ã€ retenir"

    Le **pattern DÃ©corateur** permet :
    
    - dâ€™ajouter dynamiquement des responsabilitÃ©s Ã  un objet ;
    - de composer des comportements sans explosion de sous-classes ;
    - et de respecter le **principe ouvert/fermÃ©** (*Open/Closed Principle* de SOLID*).

---

## Exercice 2 : Le pattern *Composite*

!!! note "Contexte"

    Cet exercice sâ€™appuie sur la reprÃ©sentation dâ€™un document **XML** sous forme dâ€™arbre dâ€™objets.  
    Chaque nÅ“ud du document (Ã©lÃ©ment, texte, attributâ€¦) est un objet dâ€™une hiÃ©rarchie commune.  
    Le but est de **gÃ©nÃ©rer du XML Ã  partir de cette structure**, selon le pattern **Composite**.

---

!!! Question "Question 1 â€” GÃ©nÃ©ration XML"

    On vous fournit une implÃ©mentation du **composite XML** et un exemple montrant comment extraire le texte contenu dans tout le document.

    Vous devez implÃ©menter la mÃ©thode :
    ```java
    String toXML();
    ```
    pour les diffÃ©rentes classes du composite.

    ğŸ’¡ **RÃ¨gle dâ€™affichage :**

    - Les attributs doivent Ãªtre listÃ©s **par ordre alphabÃ©tique** de leur nom (pour un comportement dÃ©terministe).
    - Vous pouvez ignorer les diffÃ©rences entre balises vides `<img/>` et `<img></img>`.


---



!!! Question "Question 2 â€” RÃ©flexion sur les patterns utilisÃ©s"

    ğŸ’­ **Analysez** votre code :

    - Quels avantages concrets vous apportent les patterns *DÃ©corateur* et *Composite* ?  
    - Quels problÃ¨mes dâ€™Ã©volution ou de maintenance auraient pu apparaÃ®tre sans eux ?  
    

