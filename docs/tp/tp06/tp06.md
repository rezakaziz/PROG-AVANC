# TP 05 : Le *Design Pattern* Template Method

[‚¨áÔ∏è T√©l√©charger le TP (tp06.zip)](tp06.zip)

!!! note "Objectif du TP"

    L‚Äôobjectif de ce TP est de r√©duire la duplication et de simplifier la structure du code d‚Äôacc√®s aux donn√©es (DAO) gr√¢ce au **design pattern comportemental : Template Method**.  
    
    Vous allez :
    
    - identifier le code r√©p√©titif dans un DAO na√Øf ;
    - cr√©er une *template* factorisant ce comportement ;
    - utiliser une version g√©n√©rique permettant le retour de r√©sultats ;
    - d√©couvrir une version avanc√©e du pattern, d√©j√† impl√©ment√©e pour vous.

---

!!! note "Instructions pr√©liminaires"

    Avant de commencer ce TP, vous devez :

    1. Cr√©er un **nouveau d√©p√¥t GitHub** nomm√© `tp05-template-method`.  
    2. Ajouter le compte **[@rezakaziz](https://github.com/rezakaziz)** comme **collaborateur**.  
    3. Cloner votre d√©p√¥t et travailler dessus :
       ```bash
       git add .
       git commit -m "progression"
       git push
       ```
    4. Les tests unitaires doivent continuer √† passer apr√®s chaque question.

---

!!! info "Note"
    Les tests unitaires sont √† √©crire par l‚Äô√©tudiant lorsqu‚Äôils ne sont pas fournis.

---

# Exercice 1 : 

!!! note "Contexte"

    On vous fournit un DAO classique, `EtudiantDAO`, extr√™mement verbeux :

    - chaque m√©thode ouvre une connexion ;
    - cr√©e un `PreparedStatement` ;
    - ex√©cute du SQL ;
    - ferme la connexion ;
    - g√®re des exceptions r√©p√©titives...

    Si l‚Äôon souhaite cr√©er un nouveau DAO ou ajouter un comportement (logging, gestion d‚Äôerreur, audit...),  
    il faut **dupliquer partout**, ce qui augmente le risque de bugs.

    ‚ûù Le but est de **factoriser le squelette** en cr√©ant une classe abstraite selon le pattern *Template Method*.

---

!!! Question "Question 1 ‚Äî Template sans valeur de retour"

    Cr√©ez une classe abstraite fournissant une m√©thode :

    ```java
    public final void executer() {
        ouvrirConnexion();
        try {
            executerAvecConnexion(connexion);
        } finally {
            fermerConnexion();
        }
    }
    ```

    Et une m√©thode √† impl√©menter :

    ```java
    protected abstract void executerAvecConnexion(Connection c);
    ```

    üîß Travail demand√© :

    - Impl√©menter cette *template*.  
    - Modifier la m√©thode `save(Etudiant e)` de `EtudiantDAO` pour utiliser votre *template method*.  

---


!!! note "Contexte"

    On remarque que certaines op√©rations comme `findById(int id)` doivent **renvoyer un r√©sultat**.  
    La template pr√©c√©dente ne peut pas √™tre utilis√©e telle quelle.

---

!!! Question "Question 2 ‚Äî Template g√©n√©rique"

    Modifiez votre template pour qu'elle puisse renvoyer une valeur :

    - soit en utilisant le type `Object` ;
    - soit (plus propre) en la rendant **g√©n√©rique**

    Une m√©thode ne renvoyant rien utilisera la classe `Void`.

    üîß Travail demand√© :

    - Impl√©menter cette nouvelle version de la *template method*.  
    - R√©√©crire `findById(int id)` pour utiliser cette nouvelle template.

---

# Exercice 2 :

!!! note "Contexte"

    Le package `templateMethod2.template` contient une version beaucoup plus avanc√©e du pattern :

    - `SQLConnectionTemplate` : gestion simple de connexion ;
    - `SQLStatementTemplate` : permet d‚Äôex√©cuter une requ√™te sur plusieurs jeux de donn√©es, avec ou sans retour ;
    - `SQLQueryTemplate` : g√®re les `SELECT` avec extraction d‚Äôobjet depuis un `ResultSet` ;
    - `SQLSimpleHelper` : fa√ßade simplifi√©e servant d‚ÄôAPI principale.

    Ces classes reposent sur le m√™me pattern, mais elles encapsulent les d√©tails complexes.

---

!!! Question "Question 3 ‚Äî R√©√©criture all√©g√©e de la DAO"

    üîß Travail demand√© :

    - √âtudier bri√®vement les classes ci-dessus :  
      commencez par `SQLConnectionTemplate`, puis `SQLStatementTemplate`, puis `SQLQueryTemplate`.
    - Utiliser ensuite **`SQLSimpleHelper`** pour r√©√©crire une version **beaucoup plus simple** de `EtudiantDAO`.

    Votre objectif :

    - r√©duire drastiquement la quantit√© de code ;
    - garder la m√™me logique m√©tier ;
    - **faire passer tous les tests existants**.

---