# Métaprogrammation en Java

[⬇️ Télécharger le TP (tp01.zip)](tp01.zip)

!!! note "Remarque préliminaire"

    Le but de ce TP n'est pas de vous inciter à utiliser des mécanismes d'introspection Java dans tous vos bouts de code. Vous devez d'abord penser à la **lisibilité** du code.  

    L'idée est de vous faire manipuler un certain nombre de mécanismes mis en œuvre dans des *frameworks* comme **Spring**, afin de comprendre leur fonctionnement interne. 

    En pratique, dans la plupart des cas, les mécanismes étudiés ici seront utilisés à travers des bibliothèques **déjà écrites**.


## Exercice 1

On veut pouvoir manipuler plus ou moins des objets dont on ne connaîtrait pas la classe à l'avance. Pensez à des objets qui seraient décrits par un fichier texte, ou des objets tirés d'une base de données.

!!! question "Question 1"

    Étudiez la fonction `Afficheur.afficher`.

    Profitez-en pour regarder la classe `IntrospectionHelper`, elle contient des méthodes qui vous seront utiles.

!!! question "Question 2"

    On veut pouvoir créer et initialiser des classes arbitraires (encore une fois, parce que la description des objets viendra par exemple de bases de données ou de fichiers textes).

    Dans un premier temps, on suppose que la classe a un constructeur par défaut. Complétez la méthode `creer` de la classe `Createur`.
    Pour bien comprendre ce qu'elle fait, vous pouvez regarder le test correspondant :

    ~~~java
        Createur<Adresse> createur = new Createur<>(Adresse.class);
        Adresse a = createur.creer();
        assertNotNull(a);
    ~~~

!!! question "Question 3"

    On veut pouvoir initialiser maintenant des champs *textes* de notre objet. Pour cela, complétez la méthode `setProprieteTexte` de la classe `Createur`.

!!! question "Question 4"

    On veut enfin avoir un peu plus de souplesse : on passe non seulement un couple nom et valeur, mais aussi la classe de la valeur en question (qu'on aura normalement récupérée aussi par introspection, mais on va s'arrêter là).

    Complétez la méthode `setChamp` de la classe `Createur`.


## Exercice 2

On a créé une annotation nommée "Label", que l'on peut mettre sur une méthode (en fait, sur un getter).

!!! question "Question"
    
    Complétez la classe `Afficheur2`, qui fait en gros la même chose que `Afficheur`, mais qui utilise, dans l'affichage, le *label* lié au getter au lieu du nom de la propriété.

    Par exemple, avec la configuration actuelle, le test suivant :

    ~~~java
    Personne2 p = new Personne2("Alfred", 1999);
    String expected = "annee de naissance : 1999 ; nom : Alfred";
    String actual = new Afficheur2().afficher(p);
    assertEquals(expected, actual);        
    ~~~

    devrait réussir. Le nom dans la classe `Personne2` n'est pas annoté et sera affiché en utilisant le nom de propriété comme dans le premier exercice. En revanche, le getter d'anneeDeNaissance est annoté, et la valeur du label devrait être utilisée.

!!! info 
    Les annotations de ce type sont extrêmement utilisées dans les *frameworks* java professionnels, comme par exemple  Spring, J2EE, Lombok ou Android.


## Exercice 3 (Prochaine Séance)

**Cet exercice est hors programme. Je l'ai laissé pour celles et ceux qui voudraient comprendre comment la classe Proxy est utilisée**.




!!! note 

    Pour créer un site web avec le rapport de test, utiliser la commande en ligne :

        mvn surefire-report:report
