# TP : GÃ©nÃ©ricitÃ© en Java

[â¬‡ï¸ TÃ©lÃ©charger le TP (tp02.zip)](tp02.zip)

!!! note "Objectif du TP"

    Lâ€™objectif de ce TP est de vous familiariser avec la **gÃ©nÃ©ricitÃ©** en Java :  
    - crÃ©ation de **classes gÃ©nÃ©riques**,  
    - utilisation des **bornes de type**,  
    - conception de **mÃ©thodes gÃ©nÃ©riques**,  
    - et comprÃ©hension des **wildcards (`? extends`, `? super`)**.

    Ces notions sont Ã  la base de la programmation moderne en Java, notamment dans les *collections* et les *frameworks* comme Spring ou Hibernate.

---

## Exercice 1 : Classes gÃ©nÃ©riques

!!! info
    Le code attendu est testÃ© automatiquement via des classes de test.  
    Vous pouvez lancer les tests directement â€” certains Ã©choueront ou ne compileront pas tant que votre code nâ€™est pas complet.

    Si nÃ©cessaire, commentez temporairement les parties de test non encore implÃ©mentÃ©es.

---

!!! Question "Question 1"

    On veut crÃ©er une classe gÃ©nÃ©rique `MaListe<T>`.

    Elle doit possÃ©der les mÃ©thodes suivantes (dont les signatures exactes sont Ã  dÃ©terminer) :

    - `ajouter` : ajoute un Ã©lÃ©ment en fin de liste  
    - `taille` : retourne la taille actuelle de la liste  
    - `element` : retourne lâ€™Ã©lÃ©ment Ã  lâ€™indice `i`  

    Votre implÃ©mentation doit permettre dâ€™exÃ©cuter le code suivant et que les autres tests de la classe `TestQ1` passent aussi :

    ~~~java
        MaListe<String> liste1 = new MaListe<>();
        liste1.ajouter("un");
        liste1.ajouter("deux");             
        assertEquals("un deux", liste1.toString());
    ~~~

    ğŸ‘‰ Vous pouvez utiliser un **tableau dâ€™Object** en interne, et le convertir au bon type au moment de la lecture.

    ğŸ§© Nâ€™oubliez pas dâ€™Ã©crire une mÃ©thode `toString()` pour que le test passe correctement.

---

!!! Question "Question 2"

    On ajoute maintenant une mÃ©thode supplÃ©mentaire Ã  `MaListe` :

    - `ajouterListe` : ajoute tous les Ã©lÃ©ments dâ€™une autre liste du mÃªme type.

    Le code suivant doit fonctionner :

    ~~~java
    MaListe<Integer> liste1 = new MaListe<>();
    MaListe<Integer> liste2 = new MaListe<>();
    liste1.ajouter(1);
    liste1.ajouter(2);
    liste2.ajouter(3);
    liste1.ajouterListe(liste2);
    assertEquals("1 2 3", liste1.toString());
    ~~~

    ğŸ’¡ VÃ©rifiez Ã©galement les autres tests de la classe `TestQ2`.

---

!!! Question "Question 3"

    On se demande si le code suivant est raisonnable :

    ~~~java
    MaListe<String> liste1 = new MaListe<>();
    liste1.ajouter("un");
    liste1.ajouter("deux");
    MaListe<Object> liste2 = new MaListe<>();
    liste2.ajouter(Integer.valueOf(3));

    liste2.ajouterListe(liste1);
    assertEquals("3 un deux", liste2.toString());
    ~~~

    ğŸ§  RÃ©flÃ©chissez : ce code **a-t-il du sens** ?  
    Sâ€™il ne compile pas, modifiez la signature de vos mÃ©thodes pour quâ€™il fonctionne **sans casser les tests prÃ©cÃ©dents**.

    ğŸ‘‰ Indice : les **wildcards** (`? extends` et `? super`) sont vos amies ici.

    VÃ©rifiez avec les tests de `TestQ3`.

---

!!! Question "Question 4"

    On veut maintenant lâ€™opÃ©ration inverse : une mÃ©thode `ajouterDansListe`, qui ajoute **tous les Ã©lÃ©ments de la liste courante** Ã  une autre liste passÃ©e en argument.

    ~~~java
    MaListe<String> liste1 = new MaListe<>();
    liste1.ajouter("un");
    liste1.ajouter("deux");
    MaListe<Object> liste2 = new MaListe<>();
    liste2.ajouter(Integer.valueOf(3)); 

    liste1.ajouterDansListe(liste2);
    assertEquals("3 un deux", liste2.toString());
    ~~~

    ğŸ§© Faites tourner les tests de `TestQ4` pour vÃ©rifier votre implÃ©mentation.

---

## Exercice 2 : MÃ©thodes gÃ©nÃ©riques

On va maintenant travailler sur des **mÃ©thodes gÃ©nÃ©riques**.  
Ces mÃ©thodes peuvent Ãªtre **statiques** et dÃ©finies **en dehors** de la classe `MaListe`.

---

!!! Question "Question 1"

    On vous demande dâ€™abord dâ€™Ã©crire la mÃ©thode `MaListeHelper.concat` dans la classe `MaListeHelper`, de sorte que le code suivant compile et fonctionne :

    ~~~java
    MaListe<String> l1 = new MaListe<>();
    l1.ajouter("a");
    MaListe<String> l2 = new MaListe<>();
    l2.ajouter("b");
    MaListe<String> l3 = MaListeHelper.concat(l1, l2);
    assertEquals("a b", l3.toString());
    ~~~

    ğŸ“ Les tests correspondants se trouvent dans `TestQ4`.

---

!!! Question "Question 2"

    On veut pouvoir concatÃ©ner deux listes de types **diffÃ©rents**, Ã  condition quâ€™ils partagent un **mÃªme super-type**.

    ~~~java
    MaListe<Integer> l1 = new MaListe<>();
    l1.ajouter(4);
    MaListe<String> l2 = new MaListe<>();
    l2.ajouter("b");
    MaListe<Object> l3 = MaListeHelper.concat(l1, l2);
    assertEquals("4 b", l3.toString());
    ~~~

    Ici, les types de base de `l1` et `l2` sont `Integer` et `String`.  
    Leur sur-type commun est `Object`.

    ğŸ”§ Modifiez la mÃ©thode `concat` pour que ce test et `TestQ5` fonctionnent.


---

