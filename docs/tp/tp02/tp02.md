# TP : Généricité en Java

[⬇️ Télécharger le TP (tp02.zip)](tp02.zip)

!!! note "Objectif du TP"

    L’objectif de ce TP est de vous familiariser avec la **généricité** en Java :  
    - création de **classes génériques**,  
    - utilisation des **bornes de type**,  
    - conception de **méthodes génériques**,  
    - et compréhension des **wildcards (`? extends`, `? super`)**.

    Ces notions sont à la base de la programmation moderne en Java, notamment dans les *collections* et les *frameworks* comme Spring ou Hibernate.

---

## Exercice 1 : Classes génériques

!!! info
    Le code attendu est testé automatiquement via des classes de test.  
    Vous pouvez lancer les tests directement — certains échoueront ou ne compileront pas tant que votre code n’est pas complet.

    Si nécessaire, commentez temporairement les parties de test non encore implémentées.

---

!!! Question "Question 1"

    On veut créer une classe générique `MaListe<T>`.

    Elle doit posséder les méthodes suivantes (dont les signatures exactes sont à déterminer) :

    - `ajouter` : ajoute un élément en fin de liste  
    - `taille` : retourne la taille actuelle de la liste  
    - `element` : retourne l’élément à l’indice `i`  

    Votre implémentation doit permettre d’exécuter le code suivant et que les autres tests de la classe `TestQ1` passent aussi :

    ~~~java
        MaListe<String> liste1 = new MaListe<>();
        liste1.ajouter("un");
        liste1.ajouter("deux");             
        assertEquals("un deux", liste1.toString());
    ~~~

    👉 Vous pouvez utiliser un **tableau d’Object** en interne, et le convertir au bon type au moment de la lecture.

    🧩 N’oubliez pas d’écrire une méthode `toString()` pour que le test passe correctement.

---

!!! Question "Question 2"

    On ajoute maintenant une méthode supplémentaire à `MaListe` :

    - `ajouterListe` : ajoute tous les éléments d’une autre liste du même type.

    Le code suivant doit fonctionner :

    ~~~java
    MaListe<Integer> liste1 = new MaListe<>();
    MaListe<Integer> liste2 = new MaListe<>();
    liste1.ajouter(1);
    liste1.ajouter(2);
    liste2.ajouter(3);
    liste1.ajouterListe(liste2);
    assertEquals("1 2 3", liste1.toString());
    ~~~

    💡 Vérifiez également les autres tests de la classe `TestQ2`.

---

!!! Question "Question 3"

    On se demande si le code suivant est raisonnable :

    ~~~java
    MaListe<String> liste1 = new MaListe<>();
    liste1.ajouter("un");
    liste1.ajouter("deux");
    MaListe<Object> liste2 = new MaListe<>();
    liste2.ajouter(Integer.valueOf(3));

    liste2.ajouterListe(liste1);
    assertEquals("3 un deux", liste2.toString());
    ~~~

    🧠 Réfléchissez : ce code **a-t-il du sens** ?  
    S’il ne compile pas, modifiez la signature de vos méthodes pour qu’il fonctionne **sans casser les tests précédents**.

    👉 Indice : les **wildcards** (`? extends` et `? super`) sont vos amies ici.

    Vérifiez avec les tests de `TestQ3`.

---

!!! Question "Question 4"

    On veut maintenant l’opération inverse : une méthode `ajouterDansListe`, qui ajoute **tous les éléments de la liste courante** à une autre liste passée en argument.

    ~~~java
    MaListe<String> liste1 = new MaListe<>();
    liste1.ajouter("un");
    liste1.ajouter("deux");
    MaListe<Object> liste2 = new MaListe<>();
    liste2.ajouter(Integer.valueOf(3)); 

    liste1.ajouterDansListe(liste2);
    assertEquals("3 un deux", liste2.toString());
    ~~~

    🧩 Faites tourner les tests de `TestQ4` pour vérifier votre implémentation.

---

## Exercice 2 : Méthodes génériques

On va maintenant travailler sur des **méthodes génériques**.  
Ces méthodes peuvent être **statiques** et définies **en dehors** de la classe `MaListe`.

---

!!! Question "Question 1"

    On vous demande d’abord d’écrire la méthode `MaListeHelper.concat` dans la classe `MaListeHelper`, de sorte que le code suivant compile et fonctionne :

    ~~~java
    MaListe<String> l1 = new MaListe<>();
    l1.ajouter("a");
    MaListe<String> l2 = new MaListe<>();
    l2.ajouter("b");
    MaListe<String> l3 = MaListeHelper.concat(l1, l2);
    assertEquals("a b", l3.toString());
    ~~~

    📎 Les tests correspondants se trouvent dans `TestQ4`.

---

!!! Question "Question 2"

    On veut pouvoir concaténer deux listes de types **différents**, à condition qu’ils partagent un **même super-type**.

    ~~~java
    MaListe<Integer> l1 = new MaListe<>();
    l1.ajouter(4);
    MaListe<String> l2 = new MaListe<>();
    l2.ajouter("b");
    MaListe<Object> l3 = MaListeHelper.concat(l1, l2);
    assertEquals("4 b", l3.toString());
    ~~~

    Ici, les types de base de `l1` et `l2` sont `Integer` et `String`.  
    Leur sur-type commun est `Object`.

    🔧 Modifiez la méthode `concat` pour que ce test et `TestQ5` fonctionnent.


---

